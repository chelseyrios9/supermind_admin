import { ErrorMessage } from "formik";
import Image from "next/image";
import { useContext, useEffect, useState } from "react";
import { RiAddLine, RiCloseLine } from "react-icons/ri";
import { Input } from "reactstrap";
import InputWrapper from "../../Utils/HOC/InputWrapper";
import { handleModifier } from "../../Utils/Validation/ModifiedErrorMessage";
import AttachmentModal from "../Attachment/AttachmentModal";
import I18NextContext from "@/Helper/I18NextContext";
import { useTranslation } from "@/app/i18n/client";
import Btn from "@/Elements/Buttons/Btn";
import axios from "axios";
import { createAttachment } from "../../Utils/AxiosUtils/API";
import useCreate from "../../Utils/Hooks/useCreate";
import { base64toBlob } from "@/Utils/BlobUtil/base64toBlob";

const PRE_PROMPT = `DIRECTIVE: Your goal is to take a description of an AI assistant and translate it into a detailed, creative prompt suitable for generating an Avatar image with DALL·E. Your response should balance creativity with specificity to ensure the resulting image aligns closely with the user's vision.
                    Steps:
                    Understand the Request: Break down the user's request into key elements. For a cityscape, these might include the time of day, architectural style, and atmosphere.
                    Add Detail: Enrich the prompt with details that enhance the visual and thematic depth. For a futuristic cityscape, consider elements like advanced technology, unique building designs, and the color palette of the sky.
                    Incorporate Mood and Atmosphere: Describe the intended mood or emotional impact of the image. Mention lighting, weather, or any specific visual effects that contribute to the atmosphere.
                    Ensure Clarity and Precision: While being creative, also be clear and precise in your descriptions. Avoid ambiguity to ensure the image generated by DALL·E will meet the user's expectations.\n`;

const ImageUploadFieldGPT = ({ values, updateId, setFieldValue, errors, multiple, loading, showImage, galleryName, ...props }) => {
  const { i18Lang } = useContext(I18NextContext);
  const { t } = useTranslation(i18Lang, 'common');
  const [modal, setModal] = useState(false);
  const [selectedImage, setSelectedImage] = useState([]);
  const storeImageObject = props.name.split("_id")[0];
  const { mutate, isLoading, data: attachedImg } = useCreate(createAttachment, false, false);
  const [isImgGenerating, setIsImgGenerating] = useState(false);
  useEffect(() => {
    if (values) {
      multiple ? setSelectedImage(values[storeImageObject]) : values[storeImageObject] ? setSelectedImage(loading ? null : [values[storeImageObject]]) : setSelectedImage([])
      setFieldValue(values?.props?.name);
    }
  }, [values[storeImageObject], loading]);
  useEffect(() => {
    if (props?.uniquename) {
      setSelectedImage(loading ? null : [props?.uniquename])
      setFieldValue(props?.name, props?.uniquename?.id);
    }
  }, [props?.uniquename, loading, showImage]);
  useEffect(() => {
    if(!isLoading && attachedImg) {
        if(multiple) {
            setFieldValue(props?.name, [attachedImg.data[0].id]);
            setSelectedImage(attachedImg.data);
        } else {
            setFieldValue(galleryName, [attachedImg.data[0].id]);
            setFieldValue(props?.name, attachedImg.data[0].id);
            storeImageObject && setFieldValue(storeImageObject, attachedImg.data[0]);
        }
    }
  }, [isLoading, attachedImg])

  const removeImage = (result) => {
    if (props.name) {
      setFieldValue(props?.name, Array.isArray(values[props.name]) ? values[props.name].filter((el) => el !== result.id) : null); setSelectedImage(selectedImage.filter((elem) => elem.id !== result.id));
      setFieldValue(storeImageObject, '')
    }
  }
  const ImageShow = () => {
    return <>
      {selectedImage?.length > 0 &&
        selectedImage?.map((result, i) => (
          <li key={i}>
            <Image src={result?.original_url} className="img-fluid" width={100} height={100} alt="remove-icon" priority />
            <p>
              <RiCloseLine className="remove-icon" onClick={() => removeImage(result)}
              />
            </p>
          </li>
        ))
      }
    </>;
  }

  async function getImageBlobFromURL(base64JsonImage) {
    const blob = base64toBlob(base64JsonImage, 'image/png');
    return new File([blob], `${values['name']}.png`, { type: "image/png" })
  };
  const generateThumbnail = async () => {
    try {
        if(!values['name']) {
            alert("Please enter supermind name...");
            return;
        }
        if(!values['short_description']) {
            alert("Please enter short description...");
            return;
        }
        if(!values['description']) {
            alert("Please enter description...");
            return;
        }
        const prompt = PRE_PROMPT + values['name'] + "\n" + values['short_description'] + "\n" + values['description']
        setIsImgGenerating(true);
        const response = await axios.post('https://api.openai.com/v1/images/generations', {
          prompt: prompt,
          model: 'dall-e-3',
          size: "1024x1024",
          response_format: 'b64_json'
        }, {
          headers: {
            'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
            'Content-Type': 'application/json',
            // 'x-cors-api-key': "temp_368b76b526936e794eb3e109cc7fb026"
          }
        });

        const file = await getImageBlobFromURL(response.data.data[0].b64_json);
        let formData = new FormData();
        formData.append(`attachments[0]`, file);
        mutate(formData);
        setIsImgGenerating(false);
    } catch (error) {
        console.error('Error fetching image:', error);
        alert("Error fetching image. Please try again")
        setIsImgGenerating(false);
    }
  }
  return (
    <>
      <ul className={`image-select-list`}>
        <li className="choosefile-input">
          <Input
            {...props}
            onClick={(event) => {
              event.preventDefault();
              setModal(props.id);
            }}
          />
          <label htmlFor={props.id}>
            <RiAddLine />
          </label>
        </li>

        <ImageShow />
        <AttachmentModal modal={modal == props.id} name={props.name} multiple={multiple} values={values} setModal={setModal} setFieldValue={setFieldValue} setSelectedImage={setSelectedImage} showImage={showImage} redirectToTabs={true} />
      </ul>
      <div className="d-flex w-100 justify-content-between align-items-center">
          <p className="help-text">{props?.helpertext}</p>
        <Btn
            title="Generate from DALL-E"
            className="btn justify-content-center"
            onClick={generateThumbnail}
            loading={isImgGenerating || isLoading}
        />
      </div>
      {errors?.[props?.name] ? <ErrorMessage name={props.name} render={(msg) => <div className="">{t(handleModifier(storeImageObject).split(' ').join(""))} {t('IsRequired')}</div>} /> : null}
    </>
  );
};

export default InputWrapper(ImageUploadFieldGPT);
